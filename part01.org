#+TITLE: Intro to Java Programming - Part 01
#+AUTHOR: Scott Runnels
#+LANGUAGE: en
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+BIND: org-latex-caption-above nil
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)
#+BEAMER_THEME: metropolis
#+BEAMER_OUTER_THEME: miniframes [subsection=false]
#+BEAMER_HEADER: \subtitle{Java - The Basics}
#+BEAMER_HEADER: \AtBeginSection[]{
# This line inserts a table of contents with the current section highlighted at
# the beginning of each section
#+BEAMER_HEADER: \begin{frame}<beamer>\frametitle{Topic}\tableofcontents[currentsection]\end{frame}
# In order to have the miniframes/smoothbars navigation bullets even though we do not use subsections 
# q.v. https://tex.stackexchange.com/questions/2072/beamer-navigation-circles-without-subsections/2078#2078
#+BEAMER_HEADER: \subsection{}
#+BEAMER_HEADER: }
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage[listings, many]{tcolorbox}
#+LATEX_HEADER: \usepackage{etoolbox}
#+LATEX_HEADER: \usepackage{local-style}
#+LATEX_HEADER: \BeforeBeginEnvironment{minted}{\begin{tcolorbox}[enhanced,boxrule=1pt,boxsep=1pt,left=1pt,right=1pt,top=-0pt,bottom=0pt,arc=0pt,toprule=0pt, rightrule=0pt,colback=white,attach boxed title to top left={yshift=-0pt},title=Code,boxed title style={colback=myblue, right=0mm, bottomrule=0pt, left=0mm, arc=0pt}]}%
#+LATEX_HEADER: \AfterEndEnvironment{minted}{\end{tcolorbox}}%
#+LATEX_HEADER: \usepackage{parskip}
* Getting Started with Programming
  :PROPERTIES:
  :header-args: :exports both :cache yes
  :END:
** Objectives
   1. Become familiar with the 'NetBeans with TMC' development environment used in this course.
   2. Learn to download and submit programming exercises.
*** Narrative                                                      :noexport:
    For the first part of this course we're going to dive right into some very
    basic usage examples of the tools you'll be using to write your code, test
    for accuracy, and even submit the code for exercises to see if you got the
    correct answer!

    To do this, we'll be using what is called "Netbeans with TMC". Netbeans is
    a very common Integrated Development Environment or "IDE" used by Java
    developers. It will help you organize your code, remind you of things you
    might not wish to simply memorize, and even give you little shortcuts that
    help make the experience of being a developer a little more enjoyable!
    There are lots of different IDEs and most developers feel pretty strongly
    about the one they use since it's what they spend most of their day in!
    Over time, as you do more more development and explore other options you
    may find you prefer a different IDE than the one we use here; however
    there's a very good reason why we'll be using this one. This course is
    based on the content at mooc.fi and they have a service which allows you to
    complete the exercises in the course in Netbeans and submit them for
    "grading". In this case, it's a test that takes your code, runs it and
    checks the output. If the output passes, you pass! This saves us from
    setting up our environment and having to troubleshoot - this lets you focus
    on one thing: Learning Java.
** The tmcbeans interface
   [[./images/part01.000.png]]
*** Narrative                                                      :noexport:
    Once you have `tmcbeans` installed, when you open tmcbeans for the first
    time you'll be asked for the username and password of your Mooc.fi account;
    enter these values and select /Log In/. The next screen should show you the
    organizational selection screen and ask for a course selection. We're using
    /Mooc.fi/ and /Java Programming I/. Once you've selected both, you can
    accept the default settings supplied by tmcbeans and when the follow-up
    /Download exercises/ screen pops up, we can make sure all options are
    selected and click on /Download/. After a short period of time, the IDE
    will open with some pre-populated projects on the left. Like you see here.
** Selecting a project
   #+beamer: \only<1>{
   #+attr_latex: :width 0.5\textwidth
   [[./images/part01.001.png]]
   #+beamer: }\only<2>{
   [[./images/part01.002.png]]
   #+beamer: }

*** Narrative                                                      :noexport:
    From here we can use the /Files/ tab to select the first project we'll look
    at. Select the project which says /Part01_01.Sandbox/ by double-clicking
    then double click through /src/, /main/, and /java/ to find /Sandbox.java/

    ::NEXT SLIDE::
    In the right hand quadrant of the screen there is some introductory source
    code pre-filled for you. This is where we will be entering the source code
    for our projects; where you will be typing commands to instruct the
    computer what to do. The first line in our /main/ function begins with two
    forward-slash characters; this denotes a comment. A comment is used to
    document your code -- think of it as a message to yourself when you come
    back to this code in six months or to the next person who reads your code.
    Anything that happens after the comment on the same line will not be
    processed by Java.
** Writing our first Java code
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
   #+begin_src java :wrap resultscode :cache yes
     public class Sandbox {
         public static void main(String[] args) {
             // Write your program here
             System.out.println("Hello world"); 
         }
     }
   #+end_src

   #+RESULTS[76f518f560acc2c3c5f3223101c35004a4a01e05]:
   #+begin_resultscode
   Hello world
   #+end_resultscode

*** Narrative                                                      :noexport:
    We're going to fill in some code of our own. In this case we're
    going to tell Java to generate text output using the command
    =System.out.println()=.  Inside of the parenthesis we'll include a
    string - which is text between quotation marks - in this case
    "Hello World". Take a few minutes to insert the line here into
    the Sandbox.java file you opened in the last step.  Notice how I
    put a ";" character at the end of the line. This tells the
    computer "this is the end of the line".

    You might have noticed some windows popping up when you filled
    out your code. These windows are /helper/ functions from your
    Integrated Development Environment or IDE. It's trying to guess
    what you're going to write and supplying options which might help
    you or provide useful documentation for what you're doing.

    With the line filled in, you /should/ have a working Java
    program. We just need to compile and run it. We'll cover what the
    word /compile/ means later.
     
** Run Your Code
   [[./images/part01.004.png]]
*** Narrative                                                      :noexport:
    select the Run bputton and the computer will compile and execute your code!
** Check Your Output
   [[./images/part01.005.png]]
*** Narrative                                                      :noexport:
    You should see your output in the /Output/ dialog box at the bottom
    of the screen! You've now written, compiled, and executed your
    first Java program.
    
** What does TMC stand for?
   #+beamer: \only<1>{
   [[./images/part01.006.png]]
   #+beamer: }\only<2>{
   [[./images/part01.007.png]]
   #+beamer: }
*** Narrative                                                      :noexport:
    The TMC package is "Test My Code". If your code executed and
    generated output without errors you can Submit the code by
    clicking on "TMC" and then selecting "Submit". This will submit
    our code to TestMyCode which compares the output of the code to
    the desired output TMC expects. Take a minute and click on /TMC/ at
    the top and then select /Submit/.

    You should see a dialog box that tells you the progress of the submission

    ::NEXT SLIDE::
    
    If everything went well, the bottom right hand portion of the
    screen should show a green "100%" indicator.

* Printing
  :PROPERTIES:
  :header-args: :exports both :cache yes
  :END:
** Objectives
   1. Learn to write a program that prints text
   2. Become familiar with executing programs
   3. Know what the term /parameter/ means
*** Narrative                                                      :noexport:
    In this section we're going to focus on writing a program that prints text,
    becoming more familiar with executing programs, and understanding what the
    term /parameter/ means.
** The System.out.println() command
   #+beamer: \only<1>{
   [[./images/part01.009.png]]
   #+beamer: }\only<2>{
   [[./images/part01.008.png]]
   #+beamer: }
*** Narrative                                                      :noexport:
    In the last section we added the =System.out.println()= command to a java
    file and made it output the text we chose. When we added the =System.out.println()= command we needed to tell it what to print, to do that, we had to provide what is called a /parameter/ between the parenthesis. 

    ::NEXT SLIDE::
    In our case, our parameter was /Hello World/. We call this /passing a parameter/; you'd say /we passed the string 'hello world' to System.out.println()/
** Program Boilerplate
   #+beamer: \only<1>{
   [[./images/part01.010.png]]
   #+beamer: }\only<2>{
   [[./images/part01.011.png]]
   #+beamer: }\only<3>{
   [[./images/part01.012.png]]

   [[./images/part01.013.png]]
   #+beamer: }
*** Narrative                                                      :noexport:
    Java requires a good deal of what programmers call /boilerplate/ it comes
    from when we used to use hot metal typesetting to make things like
    newspapers but in modern vernacular it mostly means something that is copied
    or reused without significant changes.

    In the code we ran in the last section, everything that isn't the comment - the line starting with two forward slashes - and the System.out.println() command

    ::NEXT SLIDE::

    was boilerplate. In this example, the /boilerplate/ parts of our code tell
    the computer that our program is called /Sandbox/. Java forces you to match
    the name of the program to the name of the file that contains the source
    code. Since our program is named /Sandbox/ it has to exist in a file named
    =Sandbox.java= to work.

    When the program starts, execution begins at the line that says =public static void main=

    ::NEXT SLIDE::

    and ends at the closing curly bracket.

    We'll discuss what the terms /public class/ and /public static void/ mean
    later on. In our example, we have only one command to execute since comments
    are ignored.
** Programming Exercise - Ada Lovelace
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_02.AdaLovelace=
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
   #+begin_src java :exports code :eval no
     public class AdaLovelace {
         public static void main(String[] args) {
             // Write your program here

         }
     }     
   #+end_src
    
*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
    Ada Lovelace
    #+end_resultscode
    #+LaTeX: }

*** Narrative                                                      :noexport:
    It's time to do an exercise. In =tmcbeans=, open the project
    =Part01_02.AdaLovelace= by double clicking, and continue to double click
    through /src/, /main/, /java/, and /AdaLovelace.java/

    Notice how the file named /AdaLovelace.java/ has a 'public class
    AdaLovelace' as part of the boilerplate! Our job is to write a program that
    outputs the string "Ada LoveLace". When you think you have the answer,
    submit your answer to TMC!
** Printing Multiple Lines
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
   #+begin_src java :results output :exports both  :wrap resultscode :cache yes
     public class Ohjelma {
         public static void main(String[] args) {
             System.out.println("Hello world!");
             System.out.println("... and the universe!");
         }
     }
   #+end_src

   #+RESULTS[16ccdcc712a2f534551a9eb05ea3fb3b59e83ba7]:
   #+begin_resultscode
   Hello world!
   ... and the universe!
   #+end_resultscode

*** Narrative                                                      :noexport:
    We construct programs command by command but computer generally needs to
    know when one command ends and another command begins. While computers are
    quite complex there are places where it needs some /help/ to understand what
    humans are telling it to do. Different languages use different means to tell
    the computer /this is the end of a command/. In Java, a command usually ends
    with a semicolon.

    Here we have a program with two commands. Since the =System.out.println()=
    command prints /LINES/ of text we get two lines when this code executes. 

    ::NEXT SLIDE::

    If we didn't have the semicolons at the end of lines 3 and 4 this would
    generated an error instead of text. In fact, you don't really need to start
    a every command on a new line in Java. The newlines are really there for
    humans, not the computer! The computer will understand it if it's all on one
    line as long as the semicolons are in the right place but humans are VERY
    like to get a headache if they try to read it that way.

** Programming Exercise - Once Upon a Time
*** Code
      :PROPERTIES:
      :BEAMER_opt: T
      :BEAMER_col: 0.60
      :END:
**** =Part01_03.OnceUponATime=

     Modify the program so that it will print the following text. Use _three_
     =System.out.println()= commands for printing.

   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny   
    #+begin_src java :eval no
     public class OnceUponATime {
         public static void main(String[] args) {
             // Write your program here

         }
     }
   #+end_src

*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
     Once upon a time
     there was
     a program
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    The next exercise is =Part01_03.OnceUponATime=. Load the project in tmcbeans
    and try to solve it! When you think you have it right, run your code, and
    check the output. If it looks right, submit it to TMC.
** Letting the IDE help you a bit
*** Python
    #+begin_src python :eval no
      print("Hello World")
    #+end_src
*** Java
    #+begin_src java :eval no
      System.out.println("Hello World")
    #+end_src
*** Narrative                                                      :noexport:
    Java is a notoriously /wordy/ language. A lot of languages, when they want
    to print output, the command is just "print()" but Java makes you type 22
    characters at minimum just to write =System.out.println("")=.

    Thankfully, Netbeans - and just about every editor - provides you with some
    shortcuts you can use to make your day to day use of Java just a bit better.
    Let's take a look at a quick one. In whatever, Source code file you happen
    to enter, go to the next line and type the word "sout" and hit the <TAB> key.

    :: WAIT ::

    The IDE expands sout to System.out.println("") AND moves your cursor to the
    spot between the quotes. That reduces those 22 keypresses to no more than
    five! It doesn't feel like a lot but your fingers will thank you later.
** Programming Exercise - Dinosaur
*** Code
      :PROPERTIES:
      :BEAMER_opt: T
      :BEAMER_col: 0.60
      :END:
**** =Part01_04.Dinosaur=
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
   #+begin_src java :eval no
     public class Dinosaur {
         public static void main(String[] args) {
             // Write your program here
         }
     }
   #+end_src
   
*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
     Once upon a time
     there was
     a dinosaur
    #+end_resultscode
    #+LaTeX: }

*** Narrative                                                      :noexport:

    Open the project =Part01_04.Dinosaur=. Modify the program so that it will
   print the following text. Use _three_ =System.out.println()= commands for
   printing but this time use =sout= instead of typing everything out!

** Comments
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
   #+begin_src java :eval no
     public class Comments {
         public static void main(String[] args) {
             // Printing
             System.out.println("Text to print");
             System.out.println("More text to print!");
             /* Next:
                - more on printing
                - more practice
                - variables
                - ...
             ,*/
             System.out.println("Some other text to print");
             // System.out.println("Trying stuff out")
         }
     }
   #+end_src
*** Narrative
    There are two types of comments we can use in Java. Single line comments
    which start with forward slashes like the ones you see on lines 3 and 13 and
    multi-line comments which start with a foward-slash and an asterisk and end
    with an asterisk and a forward slash - like what you see starting on line 6
    and ending on line 11.

    Comments are very useful in code. While they don't do anything - the
    compiler simply ignores them - they exist to act as reminders to the person
    reading the code. There are two axiomatic statements - axiomatic means it is
    self-evident and always true.

    The first is that it is always easier to write code than it is to read code.
    All things being equal, reading code that other people write will take more
    time than it would have for you to write.

    The second axiomatic statement is that you will certainly not remember that
    thing you think you will remember. Sometimes you come back to code a week
    later or six months later and it seems like an alien wrote the code you
    wrote previously. It's very difficult to maintain /context/ about a thing.

    Comments exist to help smooth over those issues. Using comments is a good
    way to note when something about the code is not immediately evident to a
    beginner who would be reading your code!  Sometimes, you're that beginner!

    Comments can also be used to remove a command from the code that you think
    you might want to add back later. We call this /commenting out code/. Line
    13 is a commented-out print statement!

* Reading Input
  :PROPERTIES:
  :header-args: :exports both :cache yes
  :END:
** Objectives
   1. Learn to write a program that reads text written by a user.
   2. Know what a "string" refers to in programming.
   3. Know how to join (i.e., "concatenate") strings together.
*** Narrative                                                      :noexport:
    In this section we're going to learn how to write a program that reads text
   written by a user. We'll also learn what a "string" is and how to work with
   them.
** What is input?
   - Text written by the user
   - Input arrives as a /String/
   - The =Scanner= library is used to read user input
*** Narrative                                                      :noexport:
    In programming, when we refer to /input/ we mean text which has been
    provided by the user. This can take a lot of forms. When you type your name
    and password into a site to login, that's user input. When you fill out your
    payment information, that is also user input. User input can also take forms
    other than keyboard input, user input could be a file provided to your
    program which the program is intended to modify. For this section, we'll
    focus on the type of user input where a user is providing it through the
    keyboard.

    When user input comes /into/ our program is almost always comes to us in the
    form of a String. A string is datatype which we will cover in the next
    section but for now just know that strings are, effectively, just a series
    of characters which represent text. Once we have learned how to get a String
    into a variable we'll learn some of the things we can do with Strings.

** The Scanner Library
*** 
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <1>
    :END:
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize,highlightlines={1}
   #+begin_src java :eval no 
     import java.util.Scanner; 
     public class Program {
         public static void main(String[] args) {
             Scanner scanner = new Scanner(System.in); 
         }
     }
   #+end_src
*** 
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <2>
    :END:
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize,highlightlines={4}
   #+begin_src java :eval no 
     import java.util.Scanner; 
     public class Program {
         public static void main(String[] args) {
             Scanner scanner = new Scanner(System.in); 
         }
     }
   #+end_src

*** Narrative                                                      :noexport:
    To read user input provided from the keyboard we need to use the =Scanner=
    library which is built into Java. A library is just a collection of someone
    else's code. Sometimes it's from the official Java project, sometimes it's
    code you found that helps you do what you want! While the Scanner library is built
    into Java the functionality is /enabled/ by default. This helps keep the
    size of our programs smaller since Java won't have to include very library
    we could possibly want and instead only chooses the libraries we tell it to
    include. To enable the functionality we /import/ the library. This is a very
    common phrase in programming and one that you will run into regularly in
    this course and in reading about Java or ANY programming language.
    "Importing a library" means to add that library to your program. Every
    language has a mechanism to do this. In Java, at the top of our .java file,
    before the /public class/ boilerplate, we just type /import
    java.util.Scanner;/ to import the library. Once that is in place, we can use
    any of the features that come along with Scanner. Once we've imported the
    Scanner library we have to create a Scanner.

    NEXT SLIDE

    We do this by telling our program what we want, in this case Scanner, and
    how we want to _refer_ to the scanner. This is called /declaring a
    variable/, we'll touch on this in the next lesson but for now just remember
    that variables help both the programmer and the computer keep track of
    information.

    To declare a variable called scanner of _type_ Scanner, we use the format on
    line 4. After the computer reads this line it will start tracking a Scanner
    object as the name "scanner" and it will be configured to read text from
    =System.in= which is the keyboard input into the system.
    
** Using Scanner
*** 
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <1>
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize,highlightlines={1}
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Program {
          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);
              System.out.println("Write a message: ");
              String message = scanner.nextLine();
              System.out.println(message);
          }
      }
    #+end_src
*** 
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <2>
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize,highlightlines={5}
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Program {
          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);
              System.out.println("Write a message: ");
              String message = scanner.nextLine();
              System.out.println(message);
          }
      }
    #+end_src
*** 
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <3>
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize,highlightlines={6}
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Program {
          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);
              System.out.println("Write a message: ");
              String message = scanner.nextLine();
              System.out.println(message);
          }
      }
    #+end_src
*** 
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <4>
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize,highlightlines={7}
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Program {
          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);
              System.out.println("Write a message: ");
              String message = scanner.nextLine();
              System.out.println(message);
          }
      }
    #+end_src
*** Narrative                                                      :noexport:
    Now let's look at a program which asks the user to supply some input, reads
    the input as a string and then prints it back out for the user. Just like we
    showed in the last slide we're going to /import the java.util.Scanner
    library/.

    NEXT SLIDE

    With the library imported we then declare our scanner variable of type Scanner

    NEXT SLIDE

    Next we print out a message to the user saying /Write a message/ using System.out.println

    NEXT SLIDE

    Now we create a new variable called /message/ and this variable will store
    whatever is returned by =scanner.nextLine()=. This format we see here, with
    the period before the word /scanner/ and /nextLine/ followed by parenthesis
    lets us know that we're calling the nextLine() method of the scanner object
    we declared. The =nextLine()= method will read the user input as a String
    and store it in the variable called /message/. It does this by simply
    waiting for the user to press 'enter'. Whatever it has read by the time the
    user presses 'Enter' is what will be in message. The program is currently in
    what is called a /blocking state/ - it cannot progress until the user
    provides input or the program is canceled.

    NEXT SLIDE

    Once the user has supplied input and pressed 'Enter' the program will resume
    and it will print the String that is pointed at by the =message= variable.
** Programming Exercise - Message
*** Code
      :PROPERTIES:
      :BEAMER_opt: T
      :BEAMER_col: 0.60
      :END:
**** =Part01_05.Message=
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
   #+begin_src java :eval no
     import java.util.Scanner;

     public class Message {

         public static void main(String[] args) {
             Scanner scanner = new Scanner(System.in);

             System.out.println("Write a message:");
             // Write your program here

         }
     }
   #+end_src

*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
   Write a meesage:
   Bye
   Bye
    
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    Open the project =Part01_05.Message=. Modify the program so that it will
   read text from the user and then print back what they wrote. When you run
   your program you'll be able to enter text in the "Output" window at the
   bottom.

** Fundamentals of Strings
*** Introducing Strings
    "A sample string!"
    
    #+ATTR_LaTeX: :align |c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|
    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
    |---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
    | A |   | s | a | m | p | l | e |   | s |  t |  r |  i |  n |  g |  ! |

    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :cache yes :eval no
      String message = "A sample string!";
    #+end_src

*** Narrative                                                      :noexport:
    Strings are generally another word for /text/. If we're being very specific
    Strings are a datatype - a type of data which is defined by the values it
    can take and how they can be used. Strings are a /string of characters/
    which describe how the computer sees text on a more fundamental level - as a
    sequence of individual characters.

    So far in this course we've used strings to print words to the screen and
    when it reading input. When we printed things we provided the
    =System.out.println= function with a string in quotation marks. When we read
    input from the user the nextLine() function returned a string which we
    stored in a variable.

    In practice, variables are named containers that contain information of some
    specific type. Typically when we create a variable when do it at the same
    time we're providing value for it at the same time. In this example we've
    created a variable of type String and assigned the value the text "A sample
    string!" as its value. Once we have a variable we can use it as many times
    as we want!

    The text between the quotation marks is called a /string literal/

** Concatenation
*** Joining Strings
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <1>
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :wrap resultscode :cache yes
      String start = "The beginning and ";
      String stop = "the ending";
      String message = start + stop;
      System.out.println(message);
    #+end_src

    #+RESULTS[3cf7cd284457d3100eef29eb73cec8f5b49efe4b]:
    #+begin_resultscode
    The beginning and the ending
    #+end_resultscode

*** Joining Strings
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <2>
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :wrap resultscode :cache yes
      String message = "Hello world";
      System.out.println(message + " ... and the universe");
    #+end_src

    #+RESULTS[3a2dedb67e2e43c9512062b37b0863f7144ecd11]:
    #+begin_resultscode
    Hello world ... and the universe
    #+end_resultscode
    
    
*** Narrative                                                      :noexport:
    When we join two strings to make one string we call that process
    "concatenation". In Java we can concatenate strings using the "+" operator.
    We can add two string variables and store it in a new variable.

    NEXT SLIDE

    We can even add a string literal like the phrase "... and the universe! " to
    a variable which we've stored the string "Hello world!". You're probably
    used to adding numbers using the plus sign, but from the perspective of a
    computer, if you can describe /how/ like things can be added you can add
    them! We use code to build those descriptions and Java has already described
    how to add or /concatenate/ strings - it just mooshes them together!

    
** Programming Exercise - Hi Ada Lovelace!
*** Code
      :PROPERTIES:
      :BEAMER_opt: T
      :BEAMER_col: 0.60
      :END:
**** =Part01_06.HiAdaLovelace=
     #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
     #+begin_src java :eval no
       public class HiAdaLovelace {

           public static void main(String[] args) {
               String name = "Ada Lovelace";

           }
       }

     #+end_src


*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
   Hi Ada Lovelace!
    #+end_resultscode
    #+LaTeX: }

*** Narrative                                                      :noexport:
    Modify the program so that it concatenates a string literal "Hi " and the
    contents of the variable /name/.
** Programming Exercise - Message Three Times
*** Code
      :PROPERTIES:
      :BEAMER_opt: T
      :BEAMER_col: 0.60
      :END:
**** =Part01_07.MessageThreeTimes=
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
    #+begin_src java :eval no
      import java.util.Scanner;

      public class MessageThreeTimes {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              System.out.println("Write a message: ");
              // Write your program here
          }
      }
    #+end_src


*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
    Write a message:
    Hi
    Hi
    Hi
    Hi
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    Modify the program so that it prompts the user with "Write a message: ",
    then reads input from the user using the nextLine method from Scanner but
    this time print the string three times using System.out.println().
** Programming Exercise - Greeting
*** Code
      :PROPERTIES:
      :BEAMER_opt: T
      :BEAMER_col: 0.60
      :END:
**** =Part01_08.Greeting=
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Greeting {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here
          }
      }
    #+end_src


*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
    What's your name?
    Ada
    Hi Ada
    #+end_resultscode
    #+LaTeX: }

*** Narrative                                                      :noexport:
    Generate a program that prompts the user for their name with the message
    "What's your name?" and uses Scanner to retrieve user input. Once you have
    the name print "Hi " followed by their name.
** Programming Exercise - Conversation
*** Code
      :PROPERTIES:
      :BEAMER_opt: T
      :BEAMER_col: 0.60
      :END:
**** =Part01_09.Conversation=
 #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Conversation {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              //Write your program here
          }
      }
    #+end_src
     

*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
    Greetings! How are you doing?
    Good thank you!
    Oh, how interesting. Tell me more!
    Well, there's really nothing to tell.
    Thanks for sharing!
    #+end_resultscode
    #+LaTeX: }

*** Narrative                                                      :noexport:
    Since the nextLine method from Scanner puts the program into a blocking
    state, you can use it to build something sort of like a conversation!

    Use nextLine three times to generate the displayed conversation. In this
    exercise you'll need to store a string two times. You can either create two
    String variables or you can store the second string in the first variable.
    When you re-use a variable you don't need to indicate that it's a String.

** Programming Exercise - Story
*** Code
      :PROPERTIES:
      :BEAMER_opt: T
      :BEAMER_col: 0.60
      :END:
**** =Part01_10.Story=
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Story {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here
          }
      }
    #+end_src


*** Output                                                            :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:

**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
     #+LaTeX: {\tiny
    #+begin_resultscode
    I will tell you a story, but I need some information first.
    What is the main character called?
    Bob
    What is their job?
    a builder
    Here is the story:
    Once upon a time there was Bob, who was a builder.
    On the way to work, Bob reflected on life.
    Perhaps Bob will not be a builder forever.
    #+end_resultscode
    #+LaTeX: }

*** Narrative                                                      :noexport:
    Generate a program that prompts that asks for the characters name and their
    job Then print a short story for them using those strings.

* Variables
  :PROPERTIES:
  :header-args: :exports both :cache yes
  :END:
** Objective  
*** Narrative                                                      :noexport:
    In this section we're going to learn about the other variable /types/ which are commonly used in Java.
** What is a variable?
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <1>
    :END:
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
   #+begin_src java :eval no 
     String name = "Ada Lovelace";
     int age = 42;
     double height = 5.12;
     boolean alive = false;
   #+end_src
*** Narrative
    Think of /variables/ as containers. Inside these containers we can store
    information of various /types/. In the last section we used a lot of text in
    our code which we represented as /String/ types. We often placed those
    /Strings/ in containers for later use.

    We can store quite a few different types in Java. For example, we already
    covered how we store /text/ in =String= variables. We can also store whole
    numbers as =int= values; floating-point numbers as =double= values; and even
    whether or not something is /true/ or /false/ as =boolean= values. A value
    is /assigned/ to a variable by using the equals sign. When we use this
    pattern of TYPE VARIABLE_NAME EQUAL_SIGN VALUE we are said to have
    /declared/ our variable.
    
** Variables names are unique
***   
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <1>
    :END:
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
   #+begin_src java :eval no 
     String name = "Ada Lovelace";
     String name = "Dennis Ritchie";
   #+end_src
*** 
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <2>
    :END:
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
   #+begin_src java :eval no 
     String name = "Ada Lovelace";
     name = "Dennis Ritchie";
   #+end_src
   
*** Narrative                                                      :noexport:
    
    Variable names are unique, no two variables can have the same name. If you
    try to /declare/ a variable with the same name twice, Java will generate an
    error when you go to compile your code.

   NEXT SLIDE

   You can, however, simply reassign a variable you've already declared. Here
   we've /assigned/ =name= to another value. But since we didn't /declare/ our
   variable again, Java won't mind. Do keep in mind that once you have declared
   a variable, while you _can_ change the value, the type cannot change. This
   means you can't declare a String variable and then store an Integer in that
   variable. There are a few exceptions to this rule however. If Java knows how
   to convert the value, it can store a value of a different type in a variable
   whose type doesn't match. It does this by converting the initial value. So if
   you stored the integer 10 in a variable whose type was =double= it would
   simply convert the whole number into a floating point. However, a floating
   point value cannot be stored as an Int because Java doesn't know what to do
   with it as removing the values after the period would constitute a loss of
   information.

** Programming Exercise - Various Variables
   :PROPERTIES:
   :BEAMER_opt: T
   :END:
*** Code                                                              :BMCOL:
    
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_11.VariousVariables=
    #+LaTeX: \small{
    
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      public class VariousVariables {

          public static void main(String[] args) {
              // MODIFY THESE:

              int numberOfChicken = 3;
              double baconWeight = 5.5;
              String tractor = "None!";

              // DON'T MODIFY THESE:
              System.out.println("Chicken:");
              System.out.println(numberOfChicken);
              System.out.println("Bacon (kg):");
              System.out.println(baconWeight);
              System.out.println("Tractor:");
              System.out.println(tractor);
              System.out.println("");
              System.out.println("And finally, a summary:");
              System.out.println(numberOfChicken);
              System.out.println(baconWeight);
              System.out.println(tractor);
          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\small
    #+begin_resultscode
    Chicken:
    9000
    Bacon (kg):
    0.1
    Tractor:
    Zetor

    And finally, a summary:
    9000
    0.1
    Zetor
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    If you open the project Part01_11.VariousVariables you'll see we have the code displayed here.

    If we run this code we get the output show in the middle. However, we don't
    want this output. We want to change the code so we get the output on the right.
** Naming Variables 
   :PROPERTIES:   
   :BEAMER_opt: t
   :END:
*** Bad                                                               :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.50
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
    #+begin_src java :wrap resultscode :cache yes
      double a = 3.14;
      double b = 22.0;
      double c = a * b * b;

      System.out.println(c);
    #+end_src    

    #+RESULTS[e2c29c08717128441dd0a105100423965081f18a]:
    #+begin_resultscode
    1519.76
    #+end_resultscode

*** Good                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.50
    :BEAMER_opt: T
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
    #+begin_src java :wrap resultscode :cache yes
      double pi = 3.14;
      double radius = 22.0;
      double surfaceArea = pi * radius * radius;

      System.out.println(surfaceArea);
    #+end_src    

    #+RESULTS[b1b4065510a46b92314ae61f41925210866459a2]:
    #+begin_resultscode
    1519.76
    #+end_resultscode

*** Narrative                                                      :noexport:
    Both examples here do the same thing but the example on the right is more
    explanatory when read. We can understand just from seeing the variable names
    that we're dealing with pi and a radius and calculating the surface area.

    Variable names do have some constraints. For example, variables names cannot
    contain symbols like exclamation marks and spaces are not allowed. Instead,
    at least in Java, it's common to use what is called 'mixedCase' or
    'camelCase' where the variable name starts with a lower case character and
    each new word is capitalized.
    
    Variable names should be short yet meaningful. The choice of a variable name
    should be mnemonic- that is, designed to indicate to the casual observer the
    intent of its use. One-character variable names should be avoided except for
    temporary "throwaway" variables. Common names for temporary variables are i,
    j, k, m, and n for integers; c, d, and e for characters.

    These kinds of norms are called a 'naming convention'.
    
** Reading Different Variable Types from the User
*** User input comes in as a string
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,highlightlines={9}
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Program {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              System.out.println("Write text and press enter ");
              String text = scanner.nextLine();
              System.out.println("You wrote " + text);
          }
      }
    #+end_src    

*** Narrative
    When we read input from the user, that information is almost always read in
    as a String value. Every variable in Java must be declared, it requires us
    to bring that information in as a string. This means that if we need to
    gather input from the user that /isn't/ a string - let's say we're asking
    for someone's age - we have to start with the string representation and then
    be converted to the correct type.

** Reading Integers
*** =Integer.valueOf()=   
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
    #+begin_src java  :wrap resultscode :cache yes
      String valueAsString = "42";
      int value = Integer.valueOf(valueAsString);

      System.out.println(value);
    #+end_src    

    #+RESULTS[ca8e20691802e9d33eef63dec3db2c063d91e13a]:
    #+begin_resultscode
    42
    #+end_resultscode

*** Using =Integer.valueOf()= inline
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,highlightlines={9}
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Program {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              System.out.println("Write a value ");
              int value = Integer.valueOf(scanner.nextLine());
              System.out.println("You wrote " + value);
          }
      }
    #+end_src    
    
*** Narrative                                                      :noexport:
    We can use =Integer.valueOf= to convert a string to an integer. It takes a
    string to be converted as the argument.

    We can also use =Integer.valueOf= inline. If we consider that we usually
    store the results of =scanner.nextLine()= in a string variable it's a
    reasonable assumption to say that =scanner.nextLine()= returns a String
    value. Since =Integer.valueOf()= _takes_ a String, and =scanner.nextLine()=
    _produces_ a string, we can simply use =scanner.nextLine()= as the argument
    to =Integer.valueOf= without having to create an intermediary variable.
** Programming Exercise - Integer Input
   :PROPERTIES:
   :BEAMER_opt: T
   :END:
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_12.IntegerInput=
    Write a program that asks the user for a value. The program then should print the value provided by the user.
    
    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class IntegerInput {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // write your program here

          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\small
    #+begin_example
    Write a value
    42
    You wrote 42
    #+end_example
    #+LaTeX: }
**** Break it
     Test your program with non-numeric inputs and observe how it breaks
*** Narrative                                                      :noexport:
    For this exercise we're going to request the user input a number, read that
    input with a =Scanner= and then print the value back out. One key difference
    is, once we get this working correctly, we're going to feed it non-number
    inputs and watch the way it breaks!
** Reading Doubles
*** =Double.valueOf()=    
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny
    #+begin_src java :wrap resultscode :cache yes
      String valueAsString = "42.42";
      double value = Double.valueOf(valueAsString);
      System.out.println(value);
    #+end_src    

    #+RESULTS[10376882e2fda974874fb3523f482f95ba38d628]:
    #+begin_resultscode
    42.42
    #+end_resultscode

*** Inline Use 
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,highlightlines={7}
    #+begin_src java 
          import java.util.Scanner;

          public class Program {
              public static void main(String[] args) {
                  Scanner scanner = new Scanner(System.in);
                  System.out.println("Write a value ");
                  double value = Double.valueOf(scanner.nextLine());
                  System.out.println("You wrote " + value);
              }
          }
    #+end_src    

*** Narrative                                                      :noexport:
     The =Double.valueOf()= command, much like =Integer.valueOf()=, converts a
     string to a double. 

     And just like before we can also use it inline.

** Reading Booleans
*** Booleans very similar to casting strings to numbers
    :PROPERTIES:
    :BEAMER_opt: t
    :BEAMER_env: onlyenv
    :BEAMER_act: <1>
    :END:
        #+LaTeX: {\footnotesize
   #+CAPTION: Sample inputs and outputs for .valueOf() variants
   | String                      | .valueOf()        | Value |
   |-----------------------------+-------------------+-------|
   | "100"                       | Integer.valueOf() | 100   |
   | "1,000"                     | Integer.valueOf() | ERROR |
   | "42.42"                     | Double.valueOf()  | 42.42 |
   | "42,42"                     | Double.valueOf()  | ERROR |
    #+LaTeX: }
*** Booleans very similar to casting strings to numbers
    :PROPERTIES:
    :BEAMER_opt: t
    :BEAMER_env: onlyenv
    :BEAMER_act: <2>
    :END:
        #+LaTeX: {\footnotesize
   #+CAPTION: Sample inputs and outputs for .valueOf() variants
   | String                      | .valueOf()        | Value |
   |-----------------------------+-------------------+-------|
   | "100"                       | Integer.valueOf() | 100   |
   | "1,000"                     | Integer.valueOf() | ERROR |
   | "42.42"                     | Double.valueOf()  | 42.42 |
   | "42,42"                     | Double.valueOf()  | ERROR |
   | "true"                      | Boolean.valueOf() | true  |
   | "True"                      | Boolean.valueOf() | true  |
   | "TrUe"                      | Boolean.valueOf() | true  |
   | "false"                     | Boolean.valueOf() | false |
   | "False"                     | Boolean.valueOf() | false |
   | "FaLsE"                     | Boolean.valueOf() | false |
   | "It's not raining outside!" | Boolean.valueOf() | false |
    #+LaTeX: }
*** Narrative                                                      :noexport:
    When we're converting strings to numbers as Integers or Doubles, there's not
    many blind alley ways. While there are various gotchas like /how do you make
    a number out of a string which has comma separator in the thousands place?/
    or /How do you represent floating points in a european way where they use
    comma instead of a period?/, casting strings to numbers is relatively
    straight-forward once you wrap your brain around it.

    Similarly, though significantly more restrictive, we can turn strings into
    boolean representations as well. However, it's important to understand that
    we can only turn the strings 'true' and 'false' into boolean values. We
    can't turn sentiments into boolean values. So if your program asks the user
    'Is it raining outside' and the user inputs 'It is!', that won't count as a
    truthy boolean. While we don't have to worry about the case of the word,
    lower case true is the same as capitalized true or spongebob tRuE, anything
    that is NOT true is false!
** Programming Exercise - Boolean Input
   :PROPERTIES:
   :BEAMER_opt: T
   :END:
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_14.BooleanInput=
    Write a program that asks the user for a boolean value. The program should then print the value provided by the user.
    
    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class BooleanInput {

          public static void main(String[] args) { Scanner scanner = new
              Scanner(System.in);

              // write your program here

          } }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\small
    #+begin_example
    Write something:
    santa does not exist
    True or false? false
    #+end_example
    #+LaTeX: }
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\small
    #+begin_example
    Write something:
    tRuE
    True or false? false
    #+end_example
    #+LaTeX: }

*** Narrative                                                      :noexport:
    For this exercise we're going to request the user input a string and we'll
    check it for a very basic truthyness!

** Programming Exercise - Different Types of Input
   :PROPERTIES:
   :BEAMER_opt: T
   :END:
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_15.BooleanInput=

    Write a program that asks the user for a string, an integer, a floating-point number, and a boolean. The program should then print the values given by the user.
    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class DifferentTypesOfInput {

          public static void main(String[] args) {
              Scanner scan = new Scanner(System.in);

              // Write your program here

          }
      }

    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_example
    Give a string:
    bye-bye
    Give an integer:
    11
    Give a doulbe
    4.2
    Give a boolean:
    true
    You gave the string bye-bye
    You gave the integer 11
    You gave the double 4.2
    You gave the boolean true
    #+end_example
    #+LaTeX: }

*** Narrative                                                      :noexport:
    For this exercise we're going to combine all the different ways we take a string a cast it to a different value by asking the user for a string, an integer, a doulbe, and a boolean, then we'll spit them back out!

* Calculating with Numbers
  :PROPERTIES:
  :header-args: :exports both :cache yes
  :END:
** Precedence and Parenthesis
*** Parenthesis are an easy way to control flow of operations
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java  :exports both :wrap resultscode :cache yes
      int calculationWithParens = (1 + 1) + 3 * (2 + 5);
      System.out.println(calculationWithParens);

      int calculationWithoutParens = 1 + 1 + 3 * 2 + 5;
      System.out.println(calculationWithoutParens);
    #+end_src

    #+RESULTS[90836f8f768f867e89ca9d2aeb0942c598c6ff4c]:
    #+begin_resultscode
    23
    13
    #+end_resultscode

*** Narrative                                                      :noexport:
    It's easy to do basic math in Java - and in almost any programming language
    really! Java will respect precedence - the order of operations are performed
    from left to right with parenthesis taken into account. Multiplication and
    Division are calculated before those involving addition and subtraction.
    Just like you learned in grade school.

    

    
** Programming Exercise - Seconds in a day
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_16.SecondsInADay=

    In the exercise template, implement a program that asks the user for the
    number of days. After that, the program prints the number of seconds in the
    given number of days.

    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class SecondsInADay {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here

          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
    How many days would you like to convert to seconds?
    1
    86400
    #+end_resultscode
    #+LaTeX: }
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
    How many days would you like to convert to seconds?
    3
    259200
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    We learned earlier that we could read an integer using by using
    Integer.valueOf() and the =scanner.nextLine()= commands. If you need to,
    refresh your memory with recent code you've written.

    In this example we're going to ask the user for an integer which represents
    the number of days to convert to seconds and then we'll print the number of
    seconds.
** Expressions and Statements
*** 
    [[./images/part01.014.png]]
*** 
    [[./images/part01.015.png]]
*** Narrative                                                      :noexport:
    An /expression/ is a combination of values that is turned into another value
    through a calculation or an evaluation. The /statement/ below includes the
    expression =1 + 1 + 3 * 2 + 5= which is _evaluated= prior to its assignment
    to the variable.

    The evaluation of an expression is _always_ performed before its value is
    assigned to a variable. As such the calculation =1 + 1 + 3 * 2 + 5= is only
    performed once.

    An /expression/ is evaluated where it occurs in the source code. So far,
    you've mostly seen expressions in two places. To the right of an equals sign
    when we assign a variable a value and inline with commands such as
    =Integer.valueOf()= and =System.out.println()=. In fact, in the second
    example here, there are _two_ expressions in our assignment statement! First
    the expression scanner.nextLine() is evaluated which results in a string,
    _then_ =Double.valueOf()= is evaluated which converts that string to a
    double. The result of the evaluation of those two expressions is saved in
    the =value= variable.
** Performing Math in Print statements
*** Creating new strings with =+=                                     :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: t
    :BEAMER_env: onlyenv
    :BEAMER_act: <1>
    :END:
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :exports both :wrap resultscode :cache yes
      String sampleString = "The answer to everything is " + 42;
      System.out.println(sampleString);
    #+end_src

    #+RESULTS[647344faf9faa82e77089ad91dabf276e70eb924]:
    #+begin_resultscode
    The answer to everything is 42
    #+end_resultscode

*** Creating new strings with =+=                                     :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: t
    :BEAMER_env: onlyenv
    :BEAMER_act: <2>
    :END:

   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :exports both :wrap resultscode :cache yes
      String sampleString = "The answer to everything is " + 42;
      System.out.println(sampleString);
    #+end_src

    #+RESULTS[647344faf9faa82e77089ad91dabf276e70eb924]:
    #+begin_resultscode
    The answer to everything is 42
    #+end_resultscode
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :exports both :wrap resultscode :cache yes
      System.out.println("Four: " + (2 + 2));
      System.out.println("But! Twenty-two: " + 2 + 2);
    #+end_src

    #+RESULTS[b975dc52811d151040542e3b3cb4250c9d797a45]:
    #+begin_resultscode
    Four: 4
    But! Twenty-two: 22
    #+end_resultscode

*** Narrative                                                      :noexport:
    We learned in a previous section that we could create new strings by using
    the "+" operation along with a string. When one of the operands in a +
    operation is a string, the other operand will be changed into a string. This
    is really convenient but it can create some dark corners in our code if we
    don't think them through. If we want to perform an actual addition operation
    we need to ensure we jump the line for precedence by using parenthesis! In
    this example, the /expression/ - there's that word again - 2 + 2 is
    evaluated first because its in parenthesis.
    
** Programming Exercise - Sum of Two Numbers
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_17.SumOfTwoNumbers=

    #+LaTeX: \tiny{
    
    Write a program that asks the user for two numbers. After this, the program prints the sum of the numbers given by the user.
    When you ask for multiple numbers, create a separate variable for each:


    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class SumOfTwoNumbers {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here

          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
    Give the first number:
    8
    Give the second number:
    3
    The sum of the numbers is 11
    
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
    In this exercise we'll use the skills we learned in previous
    sections to read input from the user and then sum the numbers the user
    provides.
** Programming Exercise - Sum of three numbers
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_19.SumofThreeNumbers=

    
    #+LaTeX: \tiny{
    Write a program that asks the user for three numbers. After this the program prints the sum of the numbers given by the user.


    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class SumOfThreeNumbers {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here

          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give the first number:
      8
      Give the second number:
      3
      Give the third number:
      3
      The sum of the numbers is 14
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:        
** Programming Exercise - Addition formula
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_19.AdditionFormula=

    #+LaTeX: \tiny{
    Create a program that can be used to add two integers together. In the
    beginning, the user is asked to give two integers that are to be summed. The
    program then prints the formula that describes the addition of the numbers.


    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class AdditionFormula {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // write your program here

          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give the first number:
      5
      Give the second number:
      4
      5 + 4 = 9
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
    In this exercise we are going to print our formula and the answer as well!
** Programming Exercise - Multiplication Formula
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_20.MultiplicationFormula=

    #+LaTeX: \small{
    Similar to the previous exercise, create a program that multiplies the values stored in two integer variables.
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class MultiplicationFormula {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here

          }
      }

    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give the first number:
      2
      Give the second number:
      8
      2 * 8 = 16    
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
    This is a repetition of the previous exercise, this time we're going to use
    multiplication though.
** Division
*** Integer dividend and divisor result in integer quotients        :B_block:
    #+LaTeX: \small{
    Integer divided by integer results in an integer
    #+LaTeX: \tiny{
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :exports both :wrap resultscode :cache yes
      int result = 3 / 2; 
      System.out.println(result);
    #+end_src

    #+RESULTS[a131390fb77b46f4464e356f71484194865c24f4]:
    #+begin_resultscode
    1
    #+end_resultscode

   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :exports both :wrap resultscode :cache yes
      int dividend = 2;
      int divisor = 3;
      double quotient = divisor / dividend;
      System.out.println(quotient);
    #+end_src

    #+RESULTS[203da20f28036d005840c9db0443a55a8f734d33]:
    #+begin_resultscode
    1.0
    #+end_resultscode
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :exports both :wrap resultscode :cache yes
      double dividend = 2.0;
      int divisor = 3;
      double quotient = divisor / dividend;
      System.out.println(quotient);
    #+end_src

    #+RESULTS[caa97ca456677d32bd60d04582ece11604c925ff]:
    #+begin_resultscode
    1.5
    #+end_resultscode

    #+LaTeX: }
#+LaTeX: }    
*** Narrative                                                      :noexport:
    Division of integers is slightly trickier. If all the variables in the
    division expression are integers, then the resulting value will be an
    integer as well. This is important to remember! Even if we store the result
    of the division in a double, we get the same answer.

    However, if the dividend or divisor (or both) are a floating point number, the result is a floating point number.
** Casting
*** Integer to double
    #+LaTeX: \tiny{
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :exports both :wrap resultscode :cache yes
      int divisor = 3;
      int dividend = 2;

      double result1 = (double) divisor / dividend;
      System.out.println(result1);
      double result2 =  divisor / (double) dividend;
      System.out.println(result2);
      double result3 = (double) (divisor / dividend);
      System.out.println(result3);
    #+end_src

    #+RESULTS[af5c00ad1e0949891b3b22089b72c5836df47d77]:
    #+begin_resultscode
    1.5
    1.5
    1.0
    #+end_resultscode

       #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java :exports both :wrap resultscode :cache yes
      int dividend = 3;
      int divisor = 2;

      double result = 1.0 * dividend / divisor;
      System.out.println(result);
    #+end_src

    #+RESULTS[504f320c6ff92a51bb4776e517da361ffed4b8c7]:
    #+begin_resultscode
    1.5
    #+end_resultscode
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
    #+begin_src java  :exports both :wrap resultscode :cache yes
      int dividend = 3;
      int divisor = 2;

      double result = dividend / divisor * 1.0;
      System.out.println(result);
    #+end_src

    #+RESULTS[971149dc100a21d2afc800cbe089a152e37a1f45]:
    #+begin_resultscode
    1.0
    #+end_resultscode

    #+LaTeX: }
*** Narrative
    Sometimes you have a variable or the result of an expression which is of one
    type, but you want it to be in another type. In the case of strings, we used
    =.valueOf= commands. For some other data structures such as integers and
    floating point numbers we can /cast/ from type to another type. This
    converts from type A to type B.

    In this example, while the =divisor= and =dividend= variables are integers,
    during the division expression, we are casting one, then the other to a
    floating point integer by including =double= wrapped in parens. On line 8
    though, we've used parenthesis to wrap the expression and then we cast the
    result of the expression to a double. This bears some investigation. If you
    look at the output, we get 1.5, 1.5, and then 1.0. This is because, as we
    saw on the previous slide, if one of the numbers is a float, we get a float
    answer. But on line 8, =divisor= and =dividend= are still integers, and
    while we /cast/ the quotient to a double the precision was already lost. It
    cannot be retrieved.

    We can also be less explicit in our /casting/ operations. On line 4, by
    multiplying an integer( in this case =dividend= ) with a float, we get a
    float which means the resulting expression is division of a float (the
    product of 3 times 1.0) and an integer (2). This does the same thing as a
    casting dividend to a double, but is less explicit in what its doing.

    One thing to keep in mind is that order of operations is still in effect. In
    the last example, because we work left to right in our order of operations,
    dividend is already divided by the divisor which are both integers - so we
    lose our precision and thus the .5 falls off. We could correct this with
    parenthesis to change the order of operations.

** Programming Exercise - Average of Two Numbers
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_21.AverageOfTwoNumbers=
    #+LaTeX: \small{    
    Write a program that asks the user for two integers and prints their average.
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no 
      import java.util.Scanner;

      public class AverageOfTwoNumbers {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here

          }
      }

    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give the first number:
      8
      Give the second number:
      2
      The average is 5.0
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
    For this exercise we're going to ask the user for two numbers and then provide the average of the numbers back to the user.
** Programming Exercise - Average of Three Numbers
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:

**** =Part01_22.AverageofThreeNumbers=
    #+LaTeX: \small{

    Write a program that asks the user for three integers and prints their average.

    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class AverageOfThreeNumbers {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here

          }
      }

    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give the first number:
      8
      Give the second number:
      2
      Give the third number:
      3
      The average is 4.333333333333333
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    For this exercise we're going to ask the user for three numbers and provide them the average of the three numbers.
** Programming Exercise - Simple Calculator
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:

**** =Part01_23.SimpleCalculator=
    #+LaTeX: \small{    
    Write a program that asks the user for two
    numbers and prints their sum, difference, product, and quotient. Two
    examples of the execution of the program are given below.

    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class SimpleCalculator {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here

          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give the first number:
      8
      Give the second number:
      2
      8 + 2 = 10
      8 - 2 = 6
      8 * 2 = 16
      8 / 2 = 4.0
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     

* Conditional Statements and Conditional Operation
  :PROPERTIES:
  :header-args: :exports both :cache yes
  :END:
** Conditional Statements
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,highlightlines={2}
   #+begin_src java  :exports both :wrap resultscode :cache yes
     System.out.println("Hello, world!");
     if (true) {
         System.out.println("This code is unavoidable!");
     }
   #+end_src

   #+RESULTS[9218591844ea50542cdd4244011d0104ebee2d26]:
   #+begin_resultscode
   Hello, world!
   This code is unavoidable!
   #+end_resultscode

   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,highlightlines={2}
   #+begin_src java  :exports both :wrap resultscode :cache yes
     int number = 11;
     if (number > 10) {
         System.out.println("The number was greater than 10");
     }
   #+end_src

   #+RESULTS[e6f337e3119ea559dcfeef6157aa455535581e2b]:
   #+begin_resultscode
   The number was greater than 10
   #+end_resultscode
   #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\footnotesize
   #+begin_src java  :exports both :wrap resultscode :cache yes
     int number = 11;
     boolean greaterThan10 = number > 10; 
     if (greaterThan10) {
         System.out.println("Greater than 10!");
     }
   #+end_src

   #+RESULTS[960d714fe4cf1a77a942edf439d13c8c9f574866]:
   #+begin_resultscode
   Greater than 10!
   #+end_resultscode
   
*** Narrative                                                      :noexport:
   So far, our programs have been linear. They start, they issue commands from
   top to bottom and then exit. However, much of the core need for programs is
   to do a thing if something is true. We do this through /conditional
   statements/. The example here is a very simple example of a conditional
   statement.

   On line three, we have a condition which starts with the =if= keyword and is
   followed by an expression which once evaluated will determine the flow of the
   program. If the expression evaluates to =true= then the body of the
   conditional statement - the portion between the curly braces - is evaluated.
   In our first example, our conditional statement is simply the =true= command
   which is, hopefully obviously, truthy. In the second example our conditional
   statement is =number > 10= which, since number is 11, evaluates to =11 > 10=
   which evaluates to =true= which is, again, truthy. In both cases, if the
   condition is truthy the body of the =if= statement is evaluated - in this
   case, it's just print statements.

   In the third example, we're using a boolean - a type that can only hold true
   or false - as our conditional. Since it evaluates to a truthy value, the
   associated code block is evaluated.

   Do note, that =if= statements do _not_ end in parenthesis but the statements
   within the body do unless they are, themselves, if statements.

** Programming Exercise - Speeding Ticket
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
****  =Part01_23.SpeedingTicket=

    Write a program that asks the user for an integer and prints the string "Speeding ticket!" if the input is greater than 120.
    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no :wrap resultscode :cache yes
      import java.util.Scanner;

      public class SpeedingTicket {

          public static void main(String[] args) {
              Scanner scanner = new Scanner(System.in);

              // Write your program here. 
          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give speed:
      15
    #+end_resultscode
    #+LaTeX: }

    #+LaTeX: {\tiny
    #+begin_resultscode
      Give speed:
      135
      Speeding ticket!
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    In this exercise, we ask the user for an integer and if it's greater than 120 we print the statmeent "Speeding ticket".
** Code Indentation and Block Statements
*** Code Blocks
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,highlightlines={1,2,4}
    #+begin_src java :results output  :exports both :wrap resultscode :cache yes
      public class ProgramName {
          public static void main(String[] args) {
              int number = 72;
              if (number < 100){
                  System.out.println("Number less than 100");
              }
          }
      }
    #+end_src

    #+RESULTS[b3f851d91773fd0b5f94f3e0bb4c0e84d9b93148]:
    #+begin_resultscode
    Number less than 100
    #+end_resultscode

    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,highlightlines={1,2,4}>
    #+begin_src java  :exports both :results output  :wrap resultscode :cache yes
      public class ProgramName {
      public static void main(String[] args) {
      int number = 72;
      if (number < 100){
      System.out.println("Number less than 100");
      }
      }
      }
    #+end_src

    #+RESULTS[5f831a21029988c5aeaadb44fac3ad369765709c]:
    #+begin_resultscode
    Number less than 100
    #+end_resultscode

    
*** Narrative                                                      :noexport:
    When we say /code block/ in Java, we're referring to a section enclosed by a
    pair of curly braces. Your code will be made of many code blocks, some
    nested within each other, and some in serial - one after another.

    The code sample above contains three code blocks. The first starts on line
    one with the boilerplate bit of code that defines our public class.

    The next one is at line 2, this snippet of code is in fact, the starting
    point of all programs in Java.

    Then we have a conditional statement - the =if= statement on line 4 which
    has a code block as well. Here, there are two examples which do the exact
    same thing the exact same way but look dramatically different. Java doesn't
    care about white space or indents. It can identify code blocks because they
    are wrapped in curly braces. The indentation is there for -you- and other
    programmers who might read your code. It's easier for humans to read.

    In Java it's traditional to indent by either 4 spaces or a tab. Most editors do this for you.
** Comparison Operators
*** Common Comparators    
   | Operator | Use                      |
   |----------+--------------------------|
   | >        | Greater Than             |
   | >=       | Greater Than or Equal To |
   | <        | Less Than                |
   | <=       | Less Than or Equal To    |
   | ==       | Equal To                 |
   | !=       | Not equal To             |
*** Narrative                                                      :noexport:
    This table contains some of the most common comparators used in programming.
    A few them should look familiar from math but do make a note of the double
    equals sign as this can trip you up a good number of times. In Java - and in
    most programming languages - the single equals sign is an assignment
    operator. Such as we assign the value 10 to an integer variable. The
    comparator for /equals/ is the /double equals/!
** Programming Exercise - Ancient 
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
****  =Part01_26.Ancient=

    Write a program that prompts the user for a year. If the user inputs a number
    that is smaller than 2015, then the program prints the string "Ancient
    history!".


    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Ancient {

          public static void main(String[] args) {
              Scanner scan = new Scanner(System.in);

              // Write your program here
          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give a year:
      2017
    #+end_resultscode

    #+begin_resultscode
      Give a year:
      2013
      Ancient history!
    #+end_resultscode

    #+LaTeX: }
*** Narrative                                                      :noexport:
    In this exercise we're going to ask the user for a year and if it's before
    2015 we print the sentence "Ancient history!"
** Else
*** Else statements
    #+begin_src plantuml :file /tmp/test.png
      @startuml
      if (number greater than 5?) then (yes)
        :Your number is greater than five!;
      else (no)
        :Your number is five or less!;
      endif
      @enduml
    #+end_src

    #+RESULTS:
    [[file:/tmp/test.png]]

    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,highlightlines={5}
    #+begin_src java  :exports both :wrap resultscode :cache yes
      int number = 4;

      if (number > 5) {
          System.out.println("Your number is greater than five!");
      } else {
          System.out.println("Your number is five or less!");
      }
    #+end_src

    #+RESULTS[ed433f7c8915e3bbab89c734c1e202bfa8f5ddac]:
    #+begin_resultscode
    Your number is five or less!
    #+end_resultscode

*** Narrative                                                      :noexport:
    We've walked through how to do something if the conditional statement is
    /truthy/ but that leaves a lot to be desired when it comes to making
    decisions. In the previous exercise we only printed something if the year
    was less than 2015, what if we wanted to print something if the year weren't less than 2015 as well?

    That's where /else/ comes in. Else is the other leg of the branch. An if
    statement is effectively a fork in the road. If the conditional statement is
    truthy, we follow one leg, if the if statement is falsey we follow the other
    leg.

    An =else= statement can only exist with an =if= statement and is placed
    after the closing curly brace of the if statement.

** Programming Exercise - Positivity 
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
****  =Part01_28.Positivity=

    Write a program that prompts the user for an integer and informs the user
    whether or not it is positive (greater than zero).

    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Positivity {

          public static void main(String[] args) {
              Scanner scan = new Scanner(System.in);

              // Write your program here
          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give a number:
      5
      The number is positive.    
    #+end_resultscode
    #+begin_resultscode
      Give a number:
      -2
      The number is not positive.
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    In this exercise, we're going to write code to ask the user for an integer
    and then inform them if the integer is positive or not.
** Programming Exercise - Adulthood
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_29.Adulthood=

    Write a program that prompts the user for their age and tells them whether
    or not they are an adult (18 years old or older).
    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Adulthood {

          public static void main(String[] args) {
              Scanner scan = new Scanner(System.in);

              // Write your program here 
          }
      }

    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      How old are you?
      12
      You are not an adult
    #+end_resultscode
    #+begin_resultscode
      How old are you?
      32
      You are an adult
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
    Similar to the last exercise, we're going to ask for an integer but we're
    going to tell the user if they are an adult. An adult is anyone who is 18
    years or older.
** More conditionals
*** Else If
    
    #+begin_src plantuml :file /tmp/test2.png
      @startuml
      scale .45
      if (number equals 1?) then (yes)
              :The number is one;
      else (no)
              if (number equals 2?) then (yes)
                      :The given number is two;
              else (no)
                      if (number equals 3?) then (yes)
                              :The number must be three!;
                      else (no)
                              :Something else!;
                      endif
              endif
      endif
      @enduml
    #+end_src

    #+RESULTS:
    [[file:/tmp/test2.png]]

    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java  :exports both :wrap resultscode :cache yes
      int number = 3;

      if (number == 1) {
          System.out.println("The number is one");
      } else if (number == 2) {
          System.out.println("The given number is two");
      } else if (number == 3) {
          System.out.println("The number must be three!");
      } else {
          System.out.println("Something else!");
      }
    #+end_src

    #+RESULTS[329aaba90b1be85fc6f3be8b956d153c0cf41109]:
    #+begin_resultscode
    The number must be three!
    #+end_resultscode

*** Narrative                                                      :noexport:
    Sometimes a single condition isn't enough for the question we want to
    answer. Sometimes our logic takes a more branching path. To do that, you can
    use the =else if= command. Much like =else=, =else if= allows us to add a
    conditional - basically ask another question. =else if= follows an =if= and
    comes before and =else=.

    Comparisons are made top down and *stop* once they've found a truthy
    statement.
** Programming Exercise - Larger Than or Equal To
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
**** =Part01_30.LargerThanOrEqualTo=

    Write a program that prompts the user for two integers and prints the larger
    of the two. If the numbers are the same, then the program informs us about
    this as well.

    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class LargerThanOrEqualTo {

          public static void main(String[] args) {
              Scanner scan = new Scanner(System.in);

          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give the first number:
      5
      Give the second number:
      3
      Greater number is: 5
    #+end_resultscode
    #+begin_resultscode
      Give the first number:
      5
      Give the second number:
      8
      Greater number is: 8
    #+end_resultscode
    #+begin_resultscode
      Give the first number:
      5
      Give the second number:
      5
      The numbers are equal!
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:
    In this example, we need to ask the user for two integers and print the
    larger of the two integers but if the integers are the same, we print the
    string /The numbers are equal!/
** Programming Exercise - Grades and Points
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
****  =Part01_31.GradesAndPoints=
    #+LaTeX: {\small
    The table below describes how the grade for a particular course is
    determined. Write a program that gives a course grade according to the
    provided table.
    
    | points |       grade |
    |--------+-------------|
    |    < 0 | impossible! |
    |   0-49 |      failed |
    |  50-59 |           1 |
    |  60-69 |           2 |
    |  70-79 |           3 |
    |  80-89 |           4 |
    | 90-100 |           5 |
    |  > 100 | incredible! |
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give points [0-100]:
      37
      Grade: failed
    #+end_resultscode
    #+begin_resultscode
      Give points [0-100]:
      76
      Grade: 3
    #+end_resultscode
    #+begin_resultscode
      Give points [0-100]:
      95
      Grade: 5    
    #+end_resultscode
    #+begin_resultscode
      Give points [0-100]:
      -3
      Grade: impossible!
    #+end_resultscode
    #+LaTeX: }
    
*** Narrative                                                      :noexport:
    This exercise is an increase in difficulty. We have to make a lot of
    decisions here based on the table provided. Ask the user for the number of
    points and give them their grade.
** Remainder Operations
*** The Modulo (%) Operator   
    #+LaTeX: {\tiny    
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
   #+begin_src java  :exports both :wrap resultscode :cache yes
      int remainder = 7 % 2;
      System.out.println(remainder);
   #+end_src

   #+RESULTS[ba43abe9f4893f50a92dc06db95d755124bc1fee]:
   #+begin_resultscode
   1
   #+end_resultscode

   #+begin_src java :exports both :wrap resultscode :cache yes
     int number = 800;

     if (number % 400 == 0) {
         System.out.println("The number " + number + " is divisible by four hundred.");
     } else {
         System.out.println("The number " + number + " is not divisible by four hundred.");
     }
   #+end_src

   #+RESULTS[1a86c3b3f36baafb810ecc54c046ce9dab339528]:
   #+begin_resultscode
   The number 800 is divisible by four hundred.
   #+end_resultscode

    #+LaTeX: }
*** Narrative                                                      :noexport:
    The modulo operator - the percent sign - is not used terribly often but does
    come in handy if you want to check the divisibility of a number! The modulo
    operator performs division on the two operands and returns the REMAINDER of
    the operation. When a number is divisible evenly by another there is no
    remainder so, a modulo operation would be 0.

    In the second snippet to check if a number is divisible by 400, we use
    modulo 400 and check if it evaluates to 0. If so, it's divisible by 400.
** Programming Exercise - Odd or Even
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
****  =Part01_31.OddOrEven=                                           :BMCOL:

    Write a program that prompts the user for a number and informs us whether it
    is even or odd.

    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class OddOrEven {

          public static void main(String[] args) {
              Scanner scan = new Scanner(System.in);

          }
      }

    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Give a number:
      2
      Number 2 is even.
    #+end_resultscode

    #+begin_resultscode
      Give a number:
      7
      Number 7 is odd.
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
    In this exercise we're going to ask for a number and tell the user if it's
    odd or even.
** Comparing Strings                                               :noexport:
*** The .equals() method
    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no :exports code
      boolean compareInts = 10 == 10;            // evalutes to true
      boolean compareDoubles = 42.42 == 42.42;   // evaluates to true
      boolean compareStrings = "this" == "this"; //evaluates to false
    #+end_src

    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true    
    #+begin_src java :eval no :exports code
      String sampleString = "this is my string";
      boolean compareStrings = sampleString.equals("this is my string");      // evaluates to true
      compareStrings = sampleString.equals("this is not my string");          // evaluates to false
    #+end_src
    #+latex: }
*** Narrative                                                      :noexport:
    When comparing integers, doubles, and booleans, we're not asking much of
    Java. It's fairly simple to test if 10 is 10. Things get a little more
    interesting when we ask Java to compare two strings!

    This has to do with the internal workings of strings in Java. There's a lot
    more information to be compared against. We'll get more into this in later
    sections but suffice to say that we can't simply use the double equals
    comparator on two strings. Instead, we're going to use the =.equals()=
    method.

    If we want to get technical, the equals() method is method of the String
    type. I promise we'll make that make sense later but for now, you just need
    to know that if you have a String variable, you compare it to another string
    using =.equals()=. Think of it as saying "I have a string which I have
    stored in this variable and I can compare it to other strings but asking if
    my variable equals another string". 

    In the second snippet, =sampleString= is our string variable, to compare
    sampleString to any other string, I add dot equals and pass the string we're
    comparing it to as a parameters.
** Programming Exercise - Password                                 :noexport:
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
    
    #+LaTeX: \small{
    =Part01_33.Password=

    Write a program that prompts the user for a password. If the password is
    "Caput Draconis" the program prints "Welcome!". Otherwise, the program
    prints "Off with you!"


    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Password {

          public static void main(String[] args) {
              Scanner scan = new Scanner(System.in);

              // Write your program here 
          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Password?
      Wattlebird
      Off with you!
    #+end_resultscode

    #+begin_resultscode
      Password?
      Caput Draconis
      Welcome!
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
** Programming Exercise - Same                                     :noexport:
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
    
    #+LaTeX: \small{
    =Part01_34.Same=

    Write a program that prompts the user for two strings. If the strings are the
    same, then the program prints "Same". Otherwise, it prints "Different".
    prints "Off with you!"


    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
      import java.util.Scanner;

      public class Same {

          public static void main(String[] args) {
              Scanner scan = new Scanner(System.in);

              // Write your program here. 
          }
      }
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
      Enter the first string:
      hello
      Enter the second string:
      hello
      Same
    #+end_resultscode

    #+begin_resultscode
      Enter the first string:
      hello
      Enter the second string:
      world
      Different
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
    
** Logical Operators                                               :noexport:
***                                                                   :bmcol:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.50
    :END:
    #+ATTR_LATEX: :options numbersep=5pt,breaklines=true,fontsize=\tiny,autogobble=true
   #+begin_src java :exports both :wrap resultscode :cache yes
     System.out.println(true && true);
   #+end_src

   #+RESULTS[fa6fb09d93add0562fcff28f3abbb8ad2d3b2fcb]:
   #+begin_resultscode
   true
   #+end_resultscode
   
    #+ATTR_LATEX: :options numbersep=5pt,breaklines=true,fontsize=\tiny,autogobble=true   
   #+begin_src java :exports both :wrap resultscode :cache yes
     System.out.println(true && false);
   #+end_src

   #+RESULTS[e7068e6d6f7b775e665dc293ca69209ee45cfb3d]:
   #+begin_resultscode
   false
   #+end_resultscode

   #+ATTR_LATEX: :options numbersep=5pt,breaklines=true,fontsize=\tiny,autogobble=true
   #+begin_src java :exports both  :wrap resultscode :cache yes
     System.out.println(false || true);
   #+end_src

   #+RESULTS[b26c1d1f5b644e321124436352be2976d1baf016]:
   #+begin_resultscode
   true
   #+end_resultscode

   #+ATTR_LATEX: :options numbersep=5pt,breaklines=true,fontsize=\tiny,autogobble=true
   #+begin_src java :exports both :wrap resultscode :cache yes
     System.out.println(true || false);
   #+end_src

   #+RESULTS[032de42706ff24aea93522c6ad2da4975ea6e0c3]:
   #+begin_resultscode
   true
   #+end_resultscode

   #+ATTR_LATEX: :options numbersep=5pt,breaklines=true,fontsize=\tiny,autogobble=true
   #+begin_src java :exports both  :wrap resultscode :cache yes
     System.out.println(false || false);
   #+end_src

   #+RESULTS[33e0cddce8d8290df0b740f4c1ba4dbd408d4737]:
   #+begin_resultscode
   false
   #+end_resultscode

    #+ATTR_LATEX: :options numbersep=5pt,breaklines=true,fontsize=\tiny,autogobble=true   
   #+begin_src java :exports both :wrap resultscode :cache yes
     System.out.println(!false);
   #+end_src

   #+RESULTS[dcd38f405b42971d13ce86b47a723e291d2484a8]:
   #+begin_resultscode
   true
   #+end_resultscode

*** 
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
    | Logic | Symbol     |
    |-------+------------|
    | and   | &&         |
    | or    | \vert\vert |
    | not   | !          |

*** Narrative                                                      :noexport:
    Conditional statements may consist of multiple parts where symbols referred to as /logical operators/ are used.

* Programming in our Society                                       :noexport:
  :PROPERTIES:
  :header-args: :exports both :cache yes
  :END:
* Testing                                                          :noexport:
  #+begin_src java
    public class Program {
        public static void main(String[] args) {
            String testInput = "1,50";
            System.out.println("You wrote " + Double.valueOf(testInput));
        }
    }    
  #+end_src

  #+RESULTS:

** Programming Exercise Template 
*** Code                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.60
    :END:
    =Part01_15.BooleanInput=

    #+LaTeX: \small{
    #+ATTR_LATEX: :options numbersep=5pt,linenos,breaklines=true,fontsize=\tiny,autogobble=true
    #+begin_src java :eval no
    #+end_src
    #+LaTeX: }
*** Outputs                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_col: 0.40
    :END:
**** Desired Output                                                 :B_block:
    :PROPERTIES:
    :BEAMER_opt: T
    :BEAMER_env: block
    :END:
    #+LaTeX: {\tiny
    #+begin_resultscode
    #+end_resultscode
    #+LaTeX: }
*** Narrative                                                      :noexport:     
